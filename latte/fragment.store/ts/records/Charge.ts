/**
 * Generated by xlatte
 */
module latte{

    export interface ChargeOptions{
        amount: number;
        description?: string;
        flags?: number;
        callback?: (t: Transaction) => any;
    }

    export enum ChargeBillingAddressOptions{
		/**
		 * No option specified
		 */
		NONE,

        /**
         * No billing address
         */
    	NO_ADDRESS,

        /**
         * Same billing address as shipping address
         */
		SAME_AS_SHIPPING,

        /**
         * Use a specific address
         */
        SPECIFIC_ADDRESS
	}

	/**
	 * Record for table charge
	 */
	export class Charge extends chargeBase{

		//region Static
		static FLAG_ADDRESS_NOT_NECESSARY = 8;

		/**
		 * Prompts the user to charge the specified amount
		 * @param amount
		 */
		static prompt(options: ChargeOptions){

		    let amount = options.amount;

			let description = options.description;
			let flags = options.flags || 0;
			let callback = options.callback || ((t: Transaction) => {});

			// Create Charge
			Toast.message = Charge.create(amount, description, flags).send((charge: Charge) => {

			    // Prompt Customer Data
			    charge.promptCustomerData(() => {

			        // Prompt Payment Data
			        charge.promptPaymentData(() => {

			            // Execute transaction
			            charge.executeTransaction((t: Transaction) => {

			                callback(t);

                        });

                    });

                });

				// if(c.isWalletSet) {
                //
				// 	c.wallet.driver.executeCharge(c);
                //
				// }else{
				// 	//TODO: Implement this
				// 	log("Charge.prompt: This flow part has not been implemented");
				// }

			});



		}

		//endregion

		//region Fields

        /**
         * PayMethod of the charge
         * @type {any}
         */
        payMethod: PayMethod = null;

		/**
		 * Wallet of the charge
		 * @type {any}
		 */
		wallet: Wallet = null;
		//endregion

		//region Methods

        /**
         * Executes the transaction to pay for the charge.
         * @param callback
         */
        executeTransaction(callback: (t: Transaction) => void){

            if(!this.payMethod) throw "No PayMethod";

            // Show toast
            Toast.loading();

            // Execute transaction
            this.payMethod.wallet.driver.executeTransaction(this.payMethod, this, (t: Transaction) => {

                // Hide toast
                Toast.loaded();

                // Report result
                if(callback) {
                    callback(t);
                }
            });
        }

        /**
         * Gets the metadata about the record
         *
         * @returns Object
         */
        getMetadata(): IRecordMeta {
            return {
                fields: {
                    walletName: {
                        text: strings.wallet,
                        readOnly: true,
                    },
                    idpaymethod: {
                        text: strings.payMethod,
                        type: 'record',
                        recordType: 'PayMethod',
                        loaderFunction: PayMethod.suggestionLoader(),
                        visible: 'if-inserted',
                        readOnly: true
                    },
                    idcustomer: {
                        text: strings.customer,
                        type: 'record',
                        recordType: 'Customer',
                        loaderFunction: Customer.suggestionLoader(),
                        readOnly: true
                    },
                    description: {
                        text: strings.description,
                        type: 'string',
                        readOnly: true
                    },
                    amount: {
                        text: strings.amount,
                        type: 'float',
                        readOnly: true
                    },
                    created: {
                        text: strings.created,
                        type: 'datetime',
                        readOnly: true
                    },
                    status: {
                        text: strings.status,
                        type: 'enumeration',
                        options: this.statuses,
                        readOnly: true
                    },
                    type: {
                        text: strings.type,
                        readOnly: true
                    },
                    currency:{
                        text: strings.currency,
                        readOnly: true
                    },
                    idshippingaddress:{
                        text: strings.shippingAddress,
                        type: 'record',
                        recordType: 'Address',
                        loaderFunction: Address.suggestionLoader(),
                        readOnly: true
                    },
                    idbillingaddress:{
                        text: strings.billingAddress,
                        type: 'record',
                        recordType: 'Address',
                        loaderFunction: Address.suggestionLoader(),
                        readOnly: true
                    }
                }
            }
        }

        /**
         * Raises the <c>billingAddress</c> event
         */
        onBillingAddressChanged(){
            if(this._billingAddressChanged){
                this._billingAddressChanged.raise();
            }
        }

        /**
         * Raises the <c>customer</c> event
         */
        onCustomerChanged(){
            if(this._customerChanged){
                this._customerChanged.raise();
            }
        }

        /**
         * Raises the <c>shippingAddress</c> event
         */
        onShippingAddressChanged(){
            if(this._shippingAddressChanged){
                this._shippingAddressChanged.raise();
            }

        }

        /**
         * Prompts the user data view
         * @param callback
         */
        promptCustomerData(callback: () => void){

            // Go Customer Form
            let customerView = CustomerView.prompt(this, () => {

                this.customer = customerView.customer;
                this.shippingAddress = customerView.addressView.address;

                // Obtain customer name from address
                this.customer.firstname = this.shippingAddress.firstname;
                this.customer.lastname = this.shippingAddress.lastname;

                // Save both records
                Toast.message = Message.sendCalls([
                    this.customer.saveCall(),
                    this.shippingAddress.saveCall()
                ], () => {

                    // Set pointers
                    this.idcustomer = this.customer.idcustomer;
                    this.idshippingaddress = this.shippingAddress.idaddress;

                    // Save pointers
                    this.save(() => callback());
                });

            });

            // Set current records
            customerView.customer = this.customer || new Customer();
            customerView.addressView.address = this.shippingAddress || new Address();
        }

        /**
         * Prompts the payment method view
         * @param callback
         */
        promptPaymentData(callback: () => void){

            let packNGo = () => {
                this.save(() => callback());
            };

            // Go Payment Form
            let paymentView = PaymentMethodView.prompt(this, () => {

                // Save selected payment method
                this.payMethod = paymentView.selectedMethod;
                this.idpaymethod = this.payMethod.idpaymethod;

                // Save billing address
                switch(paymentView.billingAddressOption){
                    case ChargeBillingAddressOptions.NO_ADDRESS:
                        this.billingAddress = null;
                        break;
                    case ChargeBillingAddressOptions.SAME_AS_SHIPPING:
                        this.billingAddress = this.shippingAddress;
                        break;
                    case ChargeBillingAddressOptions.SPECIFIC_ADDRESS:
                        this.billingAddress = paymentView.customAddressView.address;
                        break;
                }

                if(!this.billingAddress.idaddress) {
                    this.billingAddress.save(() => packNGo());
                }else{
                    packNGo();
                }

            });
        }

        /**
         * Saves the charge with its current progress properties (customer, addresses, etc)
         */
        saveProgress(callback: () => void){
            this.idcustomer = this.customer.idcustomer;
            this.customer = this.customer;

            if(!this.isNoShipping) {
                this.idshippingaddress = this.shippingAddress.idaddress;
            }
        }

		//endregion

		//region Events

        /**
         * Back field for event
         */
        private _billingAddressChanged: LatteEvent;

        /**
         * Gets an event raised when the value of the billingAddress property changes
         *
         * @returns {LatteEvent}
         */
        get billingAddressChanged(): LatteEvent{
            if(!this._billingAddressChanged){
                this._billingAddressChanged = new LatteEvent(this);
            }
            return this._billingAddressChanged;
        }

        /**
         * Back field for event
         */
        private _customerChanged: LatteEvent;

        /**
         * Gets an event raised when the value of the customer property changes
         *
         * @returns {LatteEvent}
         */
        get customerChanged(): LatteEvent{
            if(!this._customerChanged){
                this._customerChanged = new LatteEvent(this);
            }
            return this._customerChanged;
        }

        /**
         * Back field for event
         */
        private _shippingAddressChanged: LatteEvent;

        /**
         * Gets an event raised when the value of the shippingAddress property changes
         *
         * @returns {LatteEvent}
         */
        get shippingAddressChanged(): LatteEvent{
            if(!this._shippingAddressChanged){
                this._shippingAddressChanged = new LatteEvent(this);
            }
            return this._shippingAddressChanged;
        }
		//endregion

		//region Properties
        /**
         * Property field
         */
        private _billingAddress: Address = null;

        /**
         * Gets or sets the billing address of the charge
         *
         * @returns {Address}
         */
        get billingAddress(): Address{
            return this._billingAddress;
        }

        /**
         * Gets or sets the billing address of the charge
         *
         * @param {Address} value
         */
        set billingAddress(value: Address){

            // Check if value changed
            let changed: boolean = value !== this._billingAddress;

            // Set value
            this._billingAddress = value;

            // Trigger changed event
            if(changed){
                this.onBillingAddressChanged();
            }
        }

        /**
         * Gets the creation date as a string
         *
         * @returns {string}
         */
        get creation(): string {
            return this.created.toFormattedString() + ' ' + this.created.timeOfDay.toString();
        }

        /**
         * Property field
         */
        private _customer: Customer = null;

        /**
         * Gets or sets the customer of the charge
         *
         * @returns {Customer}
         */
        get customer(): Customer{
            return this._customer;
        }

        /**
         * Gets or sets the customer of the charge
         *
         * @param {Customer} value
         */
        set customer(value: Customer){

            // Check if value changed
            let changed: boolean = value !== this._customer;

            // Set value
            this._customer = value;

            // Trigger changed event
            if(changed){
                this.onCustomerChanged();
            }
        }

        /**
         * Gets the customer's name
         *
         * @returns {string}
         */
        get customerName(): string {
            return (this.customer || new Customer()).fullName;
        }

        /**
		 * Gets a value indicating if the address is necessary
		 *
		 * @returns {boolean}
		 */
		get isNoShipping(): boolean {
			return (this.flags & Charge.FLAG_ADDRESS_NOT_NECESSARY) == Charge.FLAG_ADDRESS_NOT_NECESSARY;
		}

		/**
		 * Gets a value indicating if there is a customer on the charge
		 *
		 * @returns {boolean}
		 */
		get isCustomerSet(): boolean {
			return this.customer instanceof Customer;
		}

		/**
		 * Gets a value indicating if there is a wallet set on the charge
		 *
		 * @returns {boolean}
		 */
		get isWalletSet(): boolean {
			return this.wallet instanceof Wallet;
		}

        /**
         * Gets the name of the paymethod
         *
         * @returns {string}
         */
        get payMethodName(): string {
            return (this.payMethod || new PayMethod()).name;
        }

        /**
		 * Property field
		 */
		private _shippingAddress: Address = null;

		/**
		 * Gets or sets the shipping address of the charge
		 *
		 * @returns {Address}
		 */
		get shippingAddress(): Address{
		    return this._shippingAddress;
		}

		/**
		 * Gets or sets the shipping address of the charge
		 *
		 * @param {Address} value
		 */
		set shippingAddress(value: Address){

		    // Check if value changed
		    let changed: boolean = value !== this._shippingAddress;

		    // Set value
		    this._shippingAddress = value;

		    // Trigger changed event
		    if(changed){
		        this.onShippingAddressChanged();
		    }
		}

        /**
         * Gets the possible statusessess
         *
         * @returns {any}
         */
        get statuses(): {[i: number]: string} {
            return {
                0:  strings.unknown,
                50: strings.fulfilled,
                60: strings.paid,
                61: strings.paymentFailed,
                62: strings.paymentToBeRest
            };
        }


        /**
         * Gets the status string
         *
         * @returns {string}
         */
        get statusString(): string {
            return this.statuses[this.status];
        }


        /**
         * Gets the wallet name
         *
         * @returns {string}
         */
        get walletName(): string {
            return (this.wallet || new Wallet()).name;
        }
		//endregion

	}
}